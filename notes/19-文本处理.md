## 文本处理

### 文本处理工具简介

Linux上文本处理三剑客：
+ grep, egrep, fgrep：文本过滤工具（模式：pattern）工具；
  + `grep`：基本正则表达式，-E，-F
  + `egrep`：扩展正则表达式， -G，-F
  + fgrep：不支持正则表达式，
+ `sed`：stream editor, 流编辑器；文本编辑工具；
+ `awk`：Linux上的实现为gawk，文本报告生成器（格式化文本）；



`正则表达式`：Regual Expression, REGEXP

由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配的功能；

分两类：

+ 基本正则表达式：BRE
+ 扩展正则表达式：ERE



### 基本正则表达式元字符

+ 字符匹配：

  + `. `：匹配任意单个字符；
  + `[]`：匹配指定范围内的任意单个字符；
  + `[^]`：匹配指定范围外的任意单个字符；
  + [:digit:]、[:lower:]、[:upper:]、[:alpha:]、[:alnum:]、[:punct:]、[:space:]

+ 匹配次数：

  + 用在要指定其出现的次数的字符的后面，用于限制其前面字符出现的次数；默认工作于贪婪模式；
    + `*`：匹配其前面的字符任意次；0,1,多次；
      + 例如：grep "x\+y"
        + abxy
        + aby
        + xxxxxy
        + yab
    + `.*`：匹配任意长度的任意字符
    + `\?`：匹配其前面的字符0次或1次；即其前面的字符是可有可无的；
    + `\+`：匹配其前面的字符1次或多次；即其面的字符要出现至少1次；
    + `\{m\}`：匹配其前面的字符m次；
    + `\{m,n\}`：匹配其前面的字符至少m次，至多n次；
    + `\{0,n\}`：至多n次
    + `\{m,\}`：至少m次

+ 位置锚定：

  + `^`：行首锚定；用于模式的`最左侧；
  + `$`：行尾锚定；用于模式的最右侧；
  + `^PATTERN$`：用于PATTERN来匹配整行；
  + `^$`：空白行；
  + `^[[:space:]]*$`：空行或包含空白字符的行；
  + 单词：**非特殊字符组成的连续字符（字符串）都称为单词；**
    + `\<` 或 ` \b`：词首锚定，用于单词模式的左侧；
    + `\>` 或 `\b`：词尾锚定，用于单词模式的右侧；
    + `\<PATTERN\>`：匹配完整单词；

+ 分组及引用

  + `\(\)`：将一个或多个字符捆绑在一起，当作一个整体进行处理；

    + `\(xy\)*ab`

    + 分组括号中的模式匹配 到的内容会被正则表达式引擎自动记录于内部的变量中，这些变量为：

      + `\1`：模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹 配到的字符；
      + `\2`：模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式所匹配到的字
      + `\3` :	...	...

    + 后向引用：引用前面的分组括号中的模式所匹配到的字符；

      + `\1`, `\2` , ...

      ```shell
      He loves his lover.
      He likes his lover.
      She likes her liker.
      She loves her liker.
      
      ~]# grep  "\(l..e\).*\1"  lovers.txt
      ```



### 扩展正则表达式元字符

与 **基本正则** 相比 不需要 `\ ` 转译

+ 字符匹配：

  + `.`：任意单个字符
  + `[]`：指定范围内的任意单个字符
  + `[^]`：指定范围外的任意单个字符

+ 次数匹配：

  + `*`：任意次，0,1或多次；

  + `?`：0次或1次，其前的字符是可有可无的；

  + `+`：其前字符至少1次；

  + `{m}`：其前的字符m次；

  + `{m,n}`：至少m次，至多n次; 

    + {0,n}
    + {m,}

  + 位置锚定

    + `^`：行首锚定；

    + `$`：行尾锚定；
    + `\<` , `\b`：词首锚定；
    + `\>`, `\b`：词尾锚定；

  + 分组及引用：

    + `()`：分组；括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中；

    + 后向引用：
      + `\1`, `\2` , ...

  + 或：

    + `a|b`：a或者b；
    + C|cat：C或cat
    + (c|C)at：cat或Cat



### grep-文本搜索工具（基本正则）

作用：根据用户指定的“模式（过滤条件”对目标文本逐行进行匹配检查；打印匹配到的行；		
模式：由**正则表达式的元字符**及**文本字符**所编写出的过滤条件；支持多文件查询并支持使用通配符



1. 语法格式：
   + `grep  [OPTIONS]  PATTERN  [FILE...]`
     + `-E`：支持使用扩展的正则表达式元字符；
   + grep  [OPTIONS]  [-e PATTERN | -f FILE]  [FILE...]

2. 常用选项

   | 选项   | 描述                                                         |
   | ------ | ------------------------------------------------------------ |
   | `-A n` | after, 后 n 行                                               |
   | `-B n` | before，前 n 行                                              |
   | `-C n` | context，前后各 n 行                                         |
   | `-i`   | ignorecase，忽略字符的大小写；                               |
   | -c     | 只输出匹配行的数量                                           |
   | -l     | 只列出符合匹配的文件名，不列出具体的匹配行                   |
   | `-n`   | 列出所有的匹配行，显示行号                                   |
   | -h     | 查询多文件时不显示文件名                                     |
   | -s     | 不显示不存在、没有匹配文本的错误信息                         |
   | `-v`   | --invert-match：显示不能被模式匹配到的行；                   |
   | `-w`   | 匹配整词                                                     |
   | `-x`   | 匹配整行                                                     |
   | -r     | 递归搜索                                                     |
   | `-q`   | --quiet, --silent：静默模式，即不输出任何信息；已退出状态表示搜索是否成功 |
   | -b     | 打印匹配行距文件头部的偏移量，以字节为单位                   |
   | `-o`   | 仅显示匹配到的字符串本身；                                   |



4. 参考实例

   1. 显示/etc/passwd文件中不以/bin/bash结尾的行；

      ```shell
      [root@ixfosa ~]# grep -v "/bin/bash$" /etc/passwd
      ```

   2. 找出/etc/passwd文件中的两位数或三位数；

      ```shell
      [root@ixfosa ~]# grep "\<[0-9]\{2,3\}\>" /etc/passwd
      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
      ...
      ```

   3. 找出/etc/rc.d/rc.sysinit或/etc/grub2.cfg文件中，以至少一个空白字符开头，且后面非空白字符的行；

      ```shell
      [root@ixfosa ~]# grep "^[[:space:]]\+[^[:space:]]" /etc/grub2.cfg
      ```

   4. 找出"netstat -tan"命令的结果中以'LISTEN'后跟0、1或多个空白字符结尾的行；

      ```shell
      [root@ixfosa ~]# netstat -tan | grep "LISTEN[[:space:]]*$"
      tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
      tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     
      tcp6       0      0 :::22                   :::*                    LISTEN     
      tcp6       0      0 ::1:25                  :::*                    LISTEN 
      ```



### egrep-文本搜索工具（扩展正则）

`egrep` 命令作用是在文件内查找指定的字符串。

**支持扩展的正则**表达式实现类似于grep文本过滤功能；与 `grep -E` 执行结果相似

egrep命令为 grep 的扩充版本, 改良了许多传统 grep 不能或不便的操作

+ grep之下不支持 ? 与 + 这两种modifier, 但egrep可以。
+ grep不支持 a|b 或 (abc|xyz) 这类”或一”比对, 但egrep可以。
+ grep在处理 {n,m} 时, 需用 \{ 与 \} 处理, 但egrep则不需要。



1. 语法格式：`egrep [OPTIONS] PATTERN [FILE...]`
   + `-G`：支持基本正则表达式
2. 常用铉锡：参照grep指令

3. 参考实例

   1. 找出/proc/meminfo文件中，所有以大写或小写S开头的行；至少有三种实现方式；

      ```shell
      # 一般情况下 PATTERN 或 字符串有空格 时 需要加 引号
      [root@ixfosa ~]# grep -i ^s /proc/meminfo 
      SwapCached:            0 kB
      SwapTotal:       4194300 kB
      SwapFree:        4194300 kB
      Shmem:              8696 kB
      Slab:              59052 kB
      SReclaimable:      21484 kB
      SUnreclaim:        37568 kB
      
      [root@ixfosa ~]# grep ^[Ss] /proc/meminfo
      
      [root@ixfosa ~]# grep -E "^(S|s)" /proc/meminfo
      [root@ixfosa ~]# egrep "^(S|s)" /proc/meminfo
      ```

   2. 显示前系统上root、long 用户的相关信息；

      ```shell
      [root@ixfosa ~]# egrep "^(root|long)\>" /etc/passwd
      root:x:0:0:ixfosa:/root:/bin/bash
      long:x:1000:1000:大龙虾,,,123456:/home/long:/bin/bash
      ```

   3. 找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号的行；

      ```shell
      [root@ixfosa ~]# egrep -o "[^[:space:]]+\>\(\)" /etc/rc.d/init.d/functions
      checkpid()
      __kill_pids_term_kill_checkpids()
      __kill_pids_term_kill()
      __pids_var_run()
      __pids_pidof()
      ```

   4. 使用echo命令输出一绝对路径，使用egrep取出基名；

      ```shell
      [root@ixfosa ~]# echo /etc/sysconfig/ | grep  -E  -o  "[^/]+/?$"
      sysconfig/
      
      [root@ixfosa ~]# echo /etc/sysconfig/long | grep  -E  -o  "[^/]+/?$"
      long
      ```

   5. 找出ifconfig命令结果中的IP地址；

      ```shell
      [root@ixfosa ~]# ifconfig | egrep -o "([0-9]{1,3}.){3}[0-9]{1,3}" 
      192.168.1.129
      255.255.255.0
      192.168.1.255
      127.0.0.1
      255.0.0.0
      ```

   6. 添加用户bash, testbash, basher以及nologin(其shell为/sbin/nologin)；而后找出/etc/passwd文件中用户名同shell名的行；

      ```shell
      ~]# grep  -E  "^([^:]+\>).*\1$"  /etc/passwd
      ```



### wc



### cut



### sort



### uniq



### diff



### patch



### sed



### awk









