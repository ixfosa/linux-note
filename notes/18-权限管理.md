## 权限管理概述

权限管理，其实就是指对不同的用户，设置不同的文件访问权限，包括对文件的读、写、删除等，在 Linux 系统中，每个用户都具有不同的权限，拿非 root 用户来说，它们只能在自己的主目录下才具有写权限，而在主目录之外，只具有访问和读权限。

Linux 系统中，文件或目录的权限信息，可以使用 `ls` 命令查看，例如

```shell
[root@ixfosa ~]# ls -l /home/
total 0
drwx------. 2 fo    fo     83 May 12 15:27 fo
drwx------. 2 long  long   83 May 12 20:20 long
```



1. 权限位：d`rwx------`. 2 fo    fo     83 May 12 15:27 fo
   + 左三位：定义 `user` (owner)的权限
   + 中三位：定义 `group` 的权限；
   + 右三位：定义 `other` 的权限

> mode：rwxrwxrwx
>
> ownership：user,  group



2. 权限：

   + `r`：readable, 读                     
   + `w`: 可修改文件的数据；
   + `x`：可将此文件运行为进程；

   创建文件默认权限：

   ```shell
   [long@ixfosa ~]$ touch test.txt
   [long@ixfosa ~]$ ll
   -rw-rw-r--. 1 long long  0 May 16 18:35 test.txt
   ```

   

3. 文件：

   + `r`：可获取文件的数据；         
   + `w`: 可修改文件的数据；		
   + `x`：可将此文件运行为进程；





4. 目录：

   + `r`：可使用`ls`命令获取其下的所有文件列表；
   + `w`: 可修改此目录下的文件列表；即创建或删除文件；
   + `x`: 可`cd`至此目录中，且可使用`ls -l`来获取所有文件的详细属性信息；

   创建目录默认权限：

   ```shell
   [long@ixfosa ~]$ mkdir dir
   
   [long@ixfosa ~]$ ll
   drwxrwxr-x. 2 long long  6 May 16 18:31 dir
   ```

   

5. 进程安全上下文：

   进程对文件的访问权限应用模型：

   1. 进程的属主与文件的属主是否相同；如果相同，则应用属主权限；
   2. 否则，则检查进程的属主是否属于文件的属组；如果是，则应用属组权限；
   3. 否则，就只能应用other的权限；



6. 权限组合机制：

   ​                   二进制  八进制

   + `---`  `000`  `0`
   + `--x`  `001`  `1`
   + `-w-`  `010`  `2`
   + `-wx`  `011`  `3`
   + `r--`  `100`  `4`
   + `r-x`  `101`  `5`
   + `rw-`  `110  `  `6`
   + `rwx`  `111`  `7`



7. 权限相加机制

   **9 个字符分属 3 类用户**，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。

   + `r`   ----   `4`
   + `w`   ----   `2`
   + `x`   ----   `1`
   + `-`   ----   `0`

> 注意：顺序都是`rwx`,无`r`或`w`或`x`时用`-`表示。

```shell
-rw------- (600) 只有所有者才有读和写的权限  (6=4+2+0    0=0+0+0   0=0+0+0  ->  600)

-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限

-rwx------ (700) 只有所有者才有读，写，执行的权限

-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限

-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限

-rw-rw-rw- (666) 每个人都有读写的权限

-rwxrwxrwx (777) 每个人都有读写和执行的权限
```



思考：用户对目录有写权限，但对目录下的文件没有写权限时，能否修改此文件内容？能否删除此文件？



## chmod-改变文件或目录权限

`chmod` 命令的英文原意是“change the permissions mode of a file”，简称为“change mode”，意为用来改变文件或目录权限的命令，但是只有文件的`属主`和超级用户`root`才能执行这个命令。

> 1. 用户仅能修改属主为自己的那些文件的权限；
>
> 2. 符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。
> 3. 使用 `-R` 选项一定要保留当前用户的执行和读取权限，否则会报错！



语法格式：

+ chmod [OPTION]... MODE[,MODE]... FILE...

  通过 `符号组合` 的方式更改目标文件或目录的权限。

+ chmod [OPTION]... OCTAL-MODE FILE...

  通过 `八进制数` 的方式更改目标文件或目录的权限。

+ chmod [OPTION]... --reference=RFILE FILE...

  通过 `参考文件` 的权限来更改目标文件或目录的权限。



OPTION：

+ -R：递归修改



MODE：

+ 符号组合，权限字母和操作符表达式
+ 采用数字（八进制）



符号组合

+ 使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和permission（权限）,每个项目的设置可以用逗号隔开。 命令chmod将修改who指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在who的位置来说明,如who的符号模式表所示:

  + 用户类型

    | who  | 用户类型 |       说明       |
    | :--: | :------: | :--------------: |
    | `u`  |   user   |    文件所有者    |
    | `g`  |  group   | 文件所有者所在组 |
    | `o`  |  others  |   所有其他用户   |
    | `a`  |   all    |     所用用户     |

  + 操作符

    | Operator |                          说明                          |
    | :------: | :----------------------------------------------------: |
    |   `+`    |                为指定的用户类型增加权限                |
    |   `-`    |                 去除指定用户类型的权限                 |
    |   `=`    | 设置指定用户权限的设置，即将用户类型的所有权限重新设置 |

  + 权限

    | 模式 |     名字     |                             说明                             |
    | :--: | :----------: | :----------------------------------------------------------: |
    | `r`  |      读      |                        设置为可读权限                        |
    | `w`  |      写      |                        设置为可写权限                        |
    | `x`  |   执行权限   |                       设置为可执行权限                       |
    | `X`  | 特殊执行权限 | 只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行 |
    | `s`  |  setuid/gid  | 当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限 |
    | `t`  |    粘贴位    | 设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位 |



参考实例

```shell
# 创建文件
[long@ixfosa ~]$ touch file.txt
[long@ixfosa ~]$ ll
-rw-rw-r--. 1 long long 0 May 16 17:58 file.txt

# 设置文件权限为  000
[long@ixfosa ~]$ chmod 000 file.txt 
[long@ixfosa ~]$ ll
----------. 1 long long 0 May 16 17:58 file.txt

# 往文件输出内容
# 属主想要操作属于自己的文件，也应该要有应的权限，但对于 root 无限制
[long@ixfosa ~]$ echo "hello linux..." > file.txt 
-bash: file.txt: Permission denied

[long@ixfosa ~]$ chmod 200 file.txt
[long@ixfosa ~]$ echo "hello linux..." > file.txt 

[long@ixfosa ~]$ cat file.txt 
cat: file.txt: Permission denied

[long@ixfosa ~]$ chmod 600 file.txt 
[long@ixfosa ~]$ cat file.txt 
hello linux...

[root@ixfosa test]# cat /home/long/file.txt 
hello linux...
```

```shell
# 添加组用户的写权限。
[long@ixfosa ~]$ chmod g+w file.txt 
[long@ixfosa ~]$ ll
total 4
-rw--w----. 1 long long 15 May 16 18:01 file.txt

# 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。
# [long@ixfosa ~]$ chmod 764 file.txt 
[long@ixfosa ~]$ chmod u=rwx,g=rw,o=r file.txt 
[long@ixfosa ~]$ ll
-rwxrw-r--. 1 long long 15 May 16 18:01 file.txt


# 使得所有用户都没有写权限。
[long@ixfosa ~]$ ll file.txt 
-rwxrw-r--. 1 long long 15 May 16 18:01 file.txt
[long@ixfosa ~]$ chmod a= file.txt 
[long@ixfosa ~]$ ll file.txt 
----------. 1 long long 15 May 16 18:01 file.txt

# 使得属主，属组都有读写权限。
[long@ixfosa ~]$ chmod ug+rw file.txt 
[long@ixfosa ~]$ ll file.txt 
-rw-rw----. 1 long long 15 May 16 18:01 file.txt


# 将目录以及目录下的文件都设置为所有用户拥有读写权限。
# 注意，使用'-R'选项一定要保留当前用户的执行和读取权限，否则会报错！
[long@ixfosa ~]$ mkdir dir
[long@ixfosa ~]$ touch dir/{test.1,test.2,test.3}
[long@ixfosa ~]$ ll dir/
-rw-rw-r--. 1 long long 0 May 16 18:39 test.1
-rw-rw-r--. 1 long long 0 May 16 18:39 test.2
-rw-rw-r--. 1 long long 0 May 16 18:39 test.3

[long@ixfosa ~]$ chmod -R a=rw dir/
chmod: cannot access ‘dir/test.1’: Permission denied
chmod: cannot access ‘dir/test.2’: Permission denied
chmod: cannot access ‘dir/test.3’: Permission denied

[long@ixfosa ~]$ cd dir/
-bash: cd: dir/: Permission denied
[long@ixfosa ~]$ chmod u+x dir/

[long@ixfosa ~]$ chmod a=rw dir/*
[long@ixfosa ~]$ ll dir/
total 0
-rw-rw-rw-. 1 long long 0 May 16 18:39 test.1
-rw-rw-rw-. 1 long long 0 May 16 18:39 test.2
-rw-rw-rw-. 1 long long 0 May 16 18:39 test.3
```

```shell
# 根据其他文件的权限设置文件权限
[long@ixfosa ~]$ chmod --reference=file.txt dir/
```



## chown-修改属主和属组

`chown` 命令 修改文件和目录的属主和属组，用户可以是用户名或者用户ID，组可以是组名或者组ID，文件是以空格分开的要改变权限的文件列表，支持通配符。

需要超级用户的权限才能执行此命令。只有**超级用户和属于组的文件所有者**才能变更文件关联组。



语法格式：

+ chown [-R]  所有者  文件或目录
+ chown [-R]  所有者:所属组  文件或目录
+ chown  [OPTION]...  --reference=RFILE   FILE...

> `-R`：表示连同子目录中的所有文件，都更改所有者。
>
> 注意，在 chown 命令中，所有者和所属组中间也可以使用点（.），但会产生一个问题，如果用户在设定账号时加入了小数点（例如 zhangsan.temp），就会造成系统误判。因此，建议使用`冒号`连接所有者和所属组。
>
> chown 命令也支持单纯的修改文件或目录的所属组，例如 `chown :group install.log` 就表示修改 install.log 文件的所属组，但修改所属组通常使用 chgrp 命令，因此并不推荐使用 chown 命令。
>
> 使用 chown 命令修改文件或目录的所有者（或所属者）时，要保证使用者用户（或用户组）存在，否则该命令无法正确执行，会提示 "invalid user" 或者 "invaild group"。



参考实例

```shell
# 由root用户创建file文件
[root@ixfosa ~]# touch test.txt
# #文件的所有者是root，普通用户user对这个文件拥有只读权限
[root@ixfosa ~]# ll
-rw-r--r--. 1 root root    0 May 16 20:10 test.txt

# 修改文件的所有者
[root@ixfosa ~]# chown long test.txt 
# 所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限
[root@ixfosa ~]# ll
-rw-r--r--. 1 long root    0 May 16 20:10 test.txt
```

```shell
# 进入 long 用户的家目录, 并创建一个文件
[root@ixfosa ~]# cd /home/long/
[root@ixfosa long]# touch test.txt
[root@ixfosa long]# ll test.txt 
-rw-r--r--. 1 root root 0 May 16 20:18 test.txt

# 切换为 long 用户
# chmod:更改"test.txt"的权限：不允许的操作 #user用户不能修改test文件的权限
[long@ixfosa ~]$ chmod 766 test.txt 
chmod: changing permissions of ‘test.txt’: Operation not permitted

# long 用户无权更改所有者为 root 用户文件的权限，
# 只有普通用户是这个文件的所有者，才可以修改文件的权限。

# 退回到root身份
# 由root用户把test文件的所有者改为 long 用户
[root@ixfosa long]# chown long test.txt

# 切换为 long 用户
# user用户由于是test文件的所有者，所以可以修改文件的权限
[long@ixfosa ~]$ chmod 766 test.txt 

# 查看权限
[long@ixfosa ~]$ ll test.txt 
-rwxrw-rw-. 1 long root 0 May 16 20:18 test.txt
```

```shell
# 查看权限
[long@ixfosa ~]$ ll test.txt 
-rwxrw-rw-. 1 long root 0 May 16 20:18 test.txt

# 当该文件属于该属主时，但该文件属组不属于 该属主的属组时
# 该属主可以修改属组，但仅可以修改为自己的基本组或附加组
[long@ixfosa ~]$ chown long:long test.txt 
[long@ixfosa ~]$ ll test.txt 
-rwxrw-rw-. 1 long long 0 May 16 20:18 test.txt

# 仅 root
[long@ixfosa ~]$ chown fo:long test.txt 
chown: changing ownership of ‘test.txt’: Operation not permitte
[long@ixfosa ~]$ chown long:fo test.txt 
chown: changing ownership of ‘test.txt’: Operation not permitted


[root@ixfosa tmp]# touch test
# 把文件 test.txt 属组改为 fo， 属组改为 long
[root@ixfosa tmp]# chown fo:long test 


# 用户 fo 不属于 long组
[root@ixfosa tmp]# ll test 
-rw-r--r--. 1 fo long 15 May 16 20:33 test
```

```shell
# 将当前目录下所有文件的拥有者都改为 user，用户组改为 group:
chown -R user:group *  
```



## chgrp-修改文件和目录的属组

`chgrp`：change group。用于变更文件或目录的所属群组。



语法格式：

+ chgrp  [OPTION]...  GROUP  FILE...
+ chgrp  [OPTION]...  --reference=RFILE FILE...

> `-R`（注意是大写）选项长作用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息。



参考实例

```shell
# 改变文件的属组属性：-v 显示指令执行过程
~]# chgrp -v fo file

#根据指定文件改变文件的群组属性：
~]# chgrp --reference=file_1 file_2

# 将 /usr/test及其子目录下的所有文件的用户组改为 long：
~]# chgrp -R long /usr/test
```



## umask-设定权限掩码

`umask `命令可用来设定权限掩码。也用来令新建文件和目录拥有默认权限

权限掩码是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。



直接通过 umask 命令获得默认权限的值

```shell
[root@ixfosa ~]# umask
0022
# root用户默认是0022，普通用户默认是 0002
```

> `umask` 默认权限其实由 `4` 个八进制数组成，但第 1 个数代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT）
>
> 注意，虽然 `umask` 默认权限是用来设定文件或目录的初始权限，但并不是直接将 umask 默认权限作为文件或目录的初始权限，还要对其进行 "再加工"



umask：文件的权限反向掩码，遮罩码；

+ 文件：666-umask
+ 目录：777-umask

+ 目录：777-umask

> 文件和目录的最大默认权限值，在 Linux 系统中，文件和目录的最大默认权限是不一样的：
>
> + 对文件来讲，其可拥有的最大默认权限是 `666`，即 `rw-rw-rw-`。也就是说，使用文件的任何用户都没有执行（`x`）权限。原因很简单，执行权限是文件的最高权限，赋予时绝对要慎重，因此绝不能在新建文件的时候就默认赋予，只能通过用户手工赋予。
> + 对目录来讲，其可拥有的最大默认权限是 777，即 `rwxrwxrwx`。



文件和目录的真正初始权限

```shell
# 文件的最大默认权限是 666
# 目录的默认权限最大可以是 777
文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限
umask: 023
    666-023=644
    777-023=754
```

> 注意：之所以文件用 666 去减 023 等于 644 ，表示文件默认不能拥有执行权限；如果减得的结果中有执行权限，则需要将其 `加 1`；



利用字母权限的方式计算文件或目录的初始权限。

+ 以 umask 值为 022 为例，分别计算新建文件和目录的初始权

+ 文件的最大默认权限是 666，换算成字母就是 "-rw-rw-rw-"，umask 的值是 022，换算成字母为 "-----w--w-"。把两个字母权限相减，得到 (-rw-rw-rw-) - (-----w--w-) = (-rw-r--r--)，这就是新建文件的初始权限。

  ```shell
  # 默认umask的值是0022
  [root@ixfosa ~]# umask
  0022
  [root@ixfosa ~]# touch test
  [root@ixfosa ~]# ll test
  -rw-r--r--. 1 root root 0 May 22 12:38 test
  ```

  

+ 目录的默认权限最大可以是 777，换算成字母就是 "drwxrwxrwx"，umask 的值是 022，也就是 "-----w--w-"。把两个字母权限相减，得到的就是新建目录的默认权限，即 (drwxrwxrwx) - (-----w--w-) = (drwxr-xr-x)。

  ```shell
  [root@ixfosa ~]# mkdir dir
  [root@ixfosa ~]# ll -d dir/
  drwxr-xr-x. 2 root root 6 May 22 12:39 dir/
  ```

  

umask默认权限的修改方法

+ umask：查看当前umask
+ umask MASK: 设置umask

```shell
[root@localhost ~]# umask 002
[root@localhost ~]# umask
0002
[root@localhost ~]# umask 033
[root@localhost ~]# umask
0033
```

> 这种方式修改的 umask 只是临时有效，一旦重启或重新登陆系统，就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件 `/etc/profile`。
>
> ```shell
> [root@ixfosa ~]# cat /etc/profile
> ...
> if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then
>  umask 002
>   # 如果UID大于199（普通用户），则使用此umask值
> else
>  umask 022
>   # 如果UID小于199（超级用户），则使用此umask值
> fi
> ...
> ```



## 特殊权限

特殊权限：`SUID`， `SGID`， `STICKY`



